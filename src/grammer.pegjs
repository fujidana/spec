/** 
 * This is a **spec** grammer file written in PEG.js (https://pegjs.org) format.
 * The parser generated by PEG.js parses a spec script and outputs a 
 * javascript object similar to the Parser AST (abstract syntax tree) described blow:
 * https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API.
 */

{
  const ERROR = 0;
  const WARNING = 1;
  const INFORMATION = 2;
  const HINT = 3;

  const INVALID_STATEMENT = { type: 'InvalidStatement' };
  const NULL_EXPRESSION = { type: 'NullExpression' };
  const NULL_LITERAL = { type: 'Literal', value: null, raw: 'null'};

  const diagnostics: any = [];

  const reservedKeywords = new Set(
    ('def|undef|rdef|constant|local|global|unglobal|delete|shared|extern|array'+
    + '|float|double|string|byte|short|long|long64|ubyte|ushort|ulong|ulong64'
    + '|if|else|while|for|in|break|continue|exit|return|quit'
    + '|memstat|savstate|reconfig|getcounts|move_all|move_cnt|sync'
    + '|lscmd|lsdef|prdef|syms'
    ).split('|')
  );

  /** 
   * create diagnostic object and store it.
   */
  function addDiagnostic(location: any, message: string, severity: number) {
    const obj = { location: location, message: message, severity };
    diagnostics.push(obj);
  }

  /**
   * Return a new range object whose 'start' is identical to 'loc' and the length is equal to 'length'.
   */
  function shortenLocation(loc: any, length: number) {
    loc.end.line = loc.start.line;
    loc.end.offset = loc.start.offset + length;
    loc.end.column = loc.start.column + length;
    return loc;
  }

  /**
   *
   */
  function diagnoseEmptyArray(elements: any[] | null, loc: any, label: string, severity: number) {
    if (!elements || elements.length === 0) {
      addDiagnostic(loc, `Expected at least one ${label}.`, severity);
      return [];
    }
    return elements;
  }

  /**
   * Make array from an array of [identifier | null, separator, location, option?].
   */
  function diagnoseListItems(elements: [any, string, any][], label: string, sepOption: number) {
    const items = [];
    for (let index = 0; index < elements.length; index++) {
      const [item, sep, locEach] = elements[index];
      if (!item) {
        addDiagnostic(locEach, `Expected ${label}.`, ERROR);
        continue;
      }
      items.push(item);

      if (index === elements.length - 1) {
        if (sep === ',') {
          addDiagnostic(locEach, `Trailing comma not allowed.`, ERROR);
        }
      } else if (sepOption === 1 && sep !== ',') {
        addDiagnostic(locEach, 'Seprator must be a comma.', ERROR);
      } else if (sepOption === 2 && sep !== ' ') {
        addDiagnostic(locEach, 'Seprator must be a whitespace.', ERROR);
      }
    }
    return items;
  }

  /**
   * Make Variable Declarators from an array of [identifier | null, separator, location, option?].
   */
  function makeDeclarators(elements: [any, string, any, any][] | null, locAll: any, label: string) {
    if (!elements || elements.length === 0) {
      addDiagnostic(locAll, `Expected at least one ${label}.`, ERROR);
      return [];
    } else if (elements[elements.length - 1][1] === ',') {
      addDiagnostic(elements[elements.length - 1][2], `Trailing comma not allowed.`, ERROR);
    }

    const declarators = [];
    for (const [identifier, separator, locEach, option] of elements) {
      if (!identifier) {
        addDiagnostic(locEach, `Expected ${label}.`, ERROR);
        continue;
      }
      let obj = { type: 'VariableDeclarator', id: identifier};
      if (option) {
        Object.assign(obj, option);
      }
      declarators.push(obj);
    }
    
    return declarators;
  }

  /**
   * Make a sequence expression from array.
   * If an array is empty or null, null is returned.
   * If an array has only one Expression, it returns the Expression itself (not array).
   * If an array has two or more expressions, it returns a Sequence Expression containing the elements.
   */
  function makeSequenceExpression(elements: any[] | null) {
    if (elements === null || elements.length === 0) {
      return null;
    } else if (elements.length === 1) {
      return elements[0];
    } else {
      return { type: 'SequenceExpression', expressions: elements };
    }
  }

  /**
   * Make nested expression for binary operation.
   * head must be an expression. tails must be [string, any]
   */
  function getBinaryExpression(head: any, tails: [string, any], option = 0) {
    return tails.reduce((accumulator: any, currentValue: any) => {
      const op = currentValue[0];
      const term = currentValue[1];
      return {
        type: option === 1 ? 'LogicalExpression' : 'BinaryExpression',
        operator: op,
        left: accumulator,
        right: term,
      };
    }, head);
  }

  /**
   *
   */
  function getEscapeSequence(char: string) {
    switch (char) {
      case 'a':
        return '\x07';
      case 'b':
        return '\b';
      case 'f':
        return '\f';
      case 'n':
        return '\n';
      case 'r':
        return '\r';
      case 't':
        return '\t';
      case '\\':
        return '\\';
      case '\'':
        return '\'';
      case '\"':
        return '\"';
      case '$':
        return '$';
      default:
        return '';
    }
  }
}


// # MAIN

start =
  body:stmt* {
    return {
      type: 'Program',
      body: body,
      x_diagnostics: diagnostics,
    };
  }


// # AUXILIARIES

eol         = '\n' / '\r\n'
eof         = !.
not_eof     = &[^'}] 
eos_not_eof = eol { } / comment / ';' eol? { } 
eos         = eol { } / comment / ';' eol? { }  / eof { }  / &['}] { }
comment     = '#' p:$(!eol .)* (eol / eof) { return {type: 'Line', value: p }; }

docstring =
  '"""' p:$(!'"""' .)* closer:'"""'? {
    if (!closer) {
      addDiagnostic(shortenLocation(location(), 3), 'Unterminated docstring.', ERROR);
    }
    return { type: 'Block', value: p };
  }

space = $(' ' / '\t' / '\\' eol / docstring { addDiagnostic(location(), 'Inline docstring not recommended.', INFORMATION); return text(); })
_1_ 'whiltespace'         = space+
_0_ 'optional whitespace' = space*
eos_space = $(' ' / '\t' / '\\' eol / docstring / eol / comment)

word = [a-zA-Z0-9_]
list_sep =
  _0_ ',' _0_ { return ','; } / _1_ { return ' '; }
comma_sep =
  _0_ ',' _0_ { return ','; }


// # STATEMENTS
 
 /**
  * BNF> statement
  * Statement with or without leading comments.
  */
stmt 'statement' =
  comments:leading_comment* statement:(empty_stmt / nonempty_stmt) {
    if (comments && comments.length > 0) {
      statement.leadingComments = comments;
    }
    return statement;
  }
  /
  comments:leading_comment+ (eof / &['}]) {
    return { type: 'EmptyStatement', loc: location(), leadingComments:comments };
  }

/**
 * Empty line containing only whitespaces and a line or block comment,
 * which is treated as the leading comments of the succeeding statement.
 */
leading_comment 'empty statement with comment' =
  $[ \t]* p:(comment / q:docstring [ \t]* (eol / eof) { return q; }) {
    return p;
  }

/**
 * Empty statement. It may contains line or block comments.
 */
empty_stmt 'empty statement' =
  (_0_ eos_not_eof / _1_ eos) {
    return { type: 'EmptyStatement', loc: location() };
  }

/**
 * Nonempty statement.
 */
nonempty_stmt 'nonempty statement' =
  _0_ p:(
    block_stmt
    / if_stmt / while_stmt / for_stmt / break_stmt / continue_stmt / return_stmt / exit_stmt
    / macro_def / undef_stmt / rdef_stmt / data_array_def / extern_array_def / variable_def / constant_def
    / delete_stmt / pattern_stmt / builtin_macro_stmt / expr_stmt
  ) {
    p.loc = location();
    return p;
  }

/**
 * <BNF> compound-statement:
 *         { statement-list }
 */
block_stmt 'block statement' =
  '{' _0_ eos? stmts:stmt* _0_ closer:'}'? tail:(_0_ p:eos { return p; })? {
    if (!closer) {
      addDiagnostic(shortenLocation(location(), 1), 'Unterminated block statement.', ERROR);
    }
    const obj: any = {
      type: 'BlockStatement',
      body: stmts ? stmts : [],
    };
    if (tail) {
      obj.trailingComments = [tail];
    }
    return obj;
  }


// ## FLOW STATEMENTS

/**
 * <BNF> if ( expression ) statement
 * <BNF> if ( expression ) statement else statement
 */
if_stmt 'if statement' =
  'if' _0_ test:(
    '(' _0_ test:expr_solo_forced? _0_ closer:')'? {
      if (!test) {
        addDiagnostic(location(), 'The test expression of if-statement must not be empty.', ERROR);
      } else if (!closer) {
        addDiagnostic(shortenLocation(location(), 1), 'Unterminated parenthesis.', ERROR);
      }
      return test;
    }
  ) _0_ eol? cons:(
    cons:nonempty_stmt? {
      if (!cons) {
        addDiagnostic(location(), 'The consequent clause of if-statement must not be empty.', ERROR);
      }
      return cons;
    }
  ) alt:(
    _0_ 'else' !word _0_ eol? alt:(
      alt:nonempty_stmt? {
        if (!alt) {
          addDiagnostic(location(), 'The altanative clause of if-statement must not be empty.', ERROR);
        }
        return alt;
      }
    ) { return alt; }
  )? {
    return {
      type: 'IfStatement',
      test: test,
      consequent: cons,
      alternate: alt,
    };
  }

/**
 * <BNF> while ( experssion ) statement
 */
while_stmt 'while statement' =
  'while' _0_ test:(
    '(' _0_ test:expr_solo_forced? _0_ closer:')'? _0_ eol? {
      if (!test) {
        addDiagnostic(shortenLocation(location(), 1), 'The test expression of while-statement must not be empty.', ERROR);
      } else if (!closer) {
        addDiagnostic(shortenLocation(location(), 1), 'Unterminated parenthesis.', ERROR);
      }
      return test;
    }
  ) body:(
    body:nonempty_stmt? {
      if (!body) {
        addDiagnostic(location(), 'The body of while-statement must not be empty.', ERROR);
      }
      return body;
    }
  ) {
    return {
      type: 'WhileStatement',
      test: test,
      body: body,
    };
  }
  
/**
 * <BNF> for ( expr_opt; expr_opt; expr_opt ) statement
 * <BNF> for (identifier in assoc-array ) statement
 * While the first and third expression in a regular for-loop can be comma-separated expressions,
 * the second expression must be a single expression.
 */
for_stmt 'for statement' =
  'for' _0_ stmt:(
    '(' _0_ stmt:(
      init:expr_solo_list? _0_ ';' _0_ test:expr_solo_forced? _0_ ';' _0_ update:expr_solo_list? {
        return {
          type: 'ForStatement',
          init: makeSequenceExpression(init),
          test: test,
          update: makeSequenceExpression(update),
        };
      }
      /
      ll:identifier _0_ 'in' !word _0_ rr:assoc_array {
        return {
          type: 'ForInStatement',
          left: ll,
          right: rr,
          each: false
        };
      }
    ) _0_ closer:')'? {
      if (!closer) {
        addDiagnostic(shortenLocation(location(), 1), 'Unterminated parenthesis.', ERROR);
      }
      return stmt;
    }
  ) _0_ eol? body:(
    body:nonempty_stmt? {
      if (!body) {
        addDiagnostic(location(), 'The body of for-statement must not be empty.', ERROR);
      }
      return body;
    }
  ) {
    stmt.body = body;
    return stmt;
  }

/**
 * <BNF> break [;]
 */
break_stmt 'break statement' =
  'break' _0_ eos {
    return { type: 'BreakStatement', label: null, };
  }

/**
 * <BNF> continue [;]
 */
continue_stmt 'continue statement' =
  'continue' _0_ eos {
    return { type: 'ContinueStatement', label: null, };
  }

/**
 * <BNF> return [expression] [;]
 * <NOTICE> not documented in Grammer Rules.
 */
return_stmt 'return statement' =
  'return' !word _0_ p:expr_solo? _0_ eos {
    return { type: 'ReturnStatement', argument: p, };
  }

/**
 * <BNF> exit [;]
 * <NOTICE> no correspondence item in Parser AST.
 * Currently not used.
 */
exit_stmt 'exit statement' =
  'exit' _0_ eos {
    return { type: 'ExitStatement', };
  }


 // ## DECLARATIONS

/**
 * <BNF> def identifier string-constant [;]
 *
 * body in FunctionDeclaration in the Parser AST must be BlockStatement or Expression.
 * params in FunctionDeclaration in the Parser AST must not be null.
 */
macro_def 'macro declaration' =
  'def' _1_ identifier:identifier_w_check _0_ params:(
    '(' _0_ params:_identifier_list_item* _0_ closer:')'? _0_ {
      if (!closer) {
        addDiagnostic(shortenLocation(location(), 1), 'Unterminated parenthesis.', ERROR);
      }
      return params ? diagnoseListItems(params, 'identifier', 1) : [];
    }
  )? _0_ body:(
    opener:"'"? _0_ eos? body:stmt* closer:"'"? _0_ eos {
      if (!opener) {
        addDiagnostic(shortenLocation(location(), 1), 'Expected macro definition body, which must be embraced by single quotes.', ERROR);
      } else if (!closer) {
        addDiagnostic(shortenLocation(location(), 1), 'Unterminated macro definition.', ERROR);
      }
      return body;
    }
  ) {
    return {
      type: 'FunctionDeclaration',
      id: identifier,
      params: params,
      // defaults: [ Expression ],
      // rest: Identifier | null,
      body: body,
      generator: false,
      expression: false,
    };
  }

_identifier_list_item =
  id:identifier_w_check sep:list_sep? {
    return [id, sep, location()];
  }
  / sep:list_sep {
    return [undefined, sep, location()];
  }

/**
 * <BNF> undef identifier-list [;]
 */
undef_stmt =
  'undef' _1_ items:(
    items:_identifier_list_item* {
      diagnoseEmptyArray(items, location(), 'identifier', ERROR);
      return items;
    }
  ) _0_ eos {
    const nodes = diagnoseListItems(items, 'identifier', 0);
    return {
      type: 'MacroStatement',
      callee: { type: 'Identifier', name: 'undef', },
      arguments: nodes,
    };
  }

/**
 * <BNF> rdef identifier expression [;]
 */
rdef_stmt =
  'rdef' _1_ p:(
    id:identifier_w_check !word _0_ expr:(
      expr:expr_multi? {
        if (!expr) {
          addDiagnostic(location(), `Expected an expression.`, ERROR);
        }
        return expr;
      }
    ) {
      return [id, expr];
    }
  )? {
    if (!p) {
      addDiagnostic(location(), `Expected following identifier and expression.`, ERROR);
      return INVALID_STATEMENT;
    }
    return {
      type: 'MacroStatement',
      callee: { type: 'Identifier', name: 'rdef', },
      arguments: p,
    };
  }

/**
 * <BNF> local data-array-declaration [;]
 * <BNF> global data-array-declaration [;]
 * <BNF> shared data-array-declaration [;]
 * <BNF> extern shared data-array-declaration [;]
 * <BNF>
 * <BNF> data-array-declaration;
 * <BNF>   array identifier[expression]
 * <BNF>   data-array-type array identifier[expression]
 * <BNF>   array identifier [expression][expression]
 * <BNF>   data-array-type array identifier[expression][expression]
 */

data_array_def 'data-array declaration' =
  scope:(
    ('local' / 'global' / 'shared') _1_
  )? unit:(
    _data_array_unit _1_
  )? 'array' _1_ items:_data_array_list_item* _0_ eos {
    return {
      type: 'VariableDeclaration',
      declarations: makeDeclarators(items, location(), 'array identifier'),
      kind: 'let',
      x_type: 'data-array',
      x_scope: scope ? scope[0] : undefined,
      x_unit: unit ? unit[0] : undefined,
    };
  }

_data_array_unit =
  'string' / 'float' / 'double'
  / 'byte' / 'short' / $('long' '64'?)
  / 'ubyte' / 'ushort' / $('ulong' '64'?)

_data_array_list_item =
  id:identifier_w_check sizes:(
    _0_ p:(
      '[' _0_ expr:expr_solo_forced? _0_ closer:']'? {
        if (!closer) {
          addDiagnostic(shortenLocation(location(), 1), 'Unterminated bracket.', ERROR);
        } else if (!expr) {
          addDiagnostic(location(), 'Array size must be sepcified.', ERROR);
          expr = NULL_LITERAL;
        }
        return expr;
      }
    ) { return p; }
  )* sep:list_sep? {
    if (!sizes || sizes.length === 0) {
      addDiagnostic(location(), 'Array size must be sepcified.', ERROR);
    }
    return [ id, sep, location(), { x_sizes: sizes } ];
  }
  /
  sep:list_sep {
    return [ undefined, sep, location(), undefined];
  }  

extern_array_def =
  'extern' _1_ 'shared' _1_ 'array' _1_ items:_extern_array_list_item* _0_ eos {
    return {
      type: 'VariableDeclaration',
      declarations: makeDeclarators(items, location(), 'external array identifier'),
      kind: 'let',
      x_type: 'data-array',
      x_scope: 'extern',
      x_size: undefined,
    };
  }

_extern_array_list_item =
  spec_pid:(
    spec:$word+ _0_ ':' _0_ pid:(
      pid:$word+ _0_ ':' _0_ { return pid; }
    )? {return [spec, pid]; }
  )? id:identifier_w_check sep:list_sep? {
    const spec = spec_pid ? spec_pid[0] : null;
    const pid = spec_pid ? spec_pid[1] : null;
    return [id, sep, location(), { x_spec: spec, x_pid: pid }];
  }
  /
  sep:list_sep {
    return [undefined, sep, location(), undefined];
  }
    
/**
 * <BNF> local identifier-list [;]
 * <BNF> global identifier-list [;]
 * <BNF> unglobal identifier-list [;]
 */
variable_def 'variable declaration' =
  scope:('local' / 'global' / 'unglobal') _1_ items:_variable_list_item* _0_ eos {
    return {
      type: 'VariableDeclaration',
      declarations: makeDeclarators(items, location(), 'variable identifier'),
      kind: 'let',
      x_scope: scope,
    };
  }

_variable_list_item =
  id:identifier_w_check bracket:(
    _0_ p:(
      '[' _0_ closer:']'? {
        if (!closer) {
          addDiagnostic(shortenLocation(location(), 1), 'Unterminated bracket.', ERROR);
        }
        return true;
      }
    ) { return p; }
  )? sep:list_sep? {
    return [ id, sep, location(), { x_type: bracket !== null ? 'assoc-array' : 'scalar', } ];
  }
  /
  sep:list_sep {
    return [ undefined, sep, location(), undefined];
  }

/**
 * <BNF> constant identifier expression [;]
 * <BNF> constant identifier = expression [;]
 */
constant_def 'constant declaration' =
  'constant' _1_ items:(
    id:identifier_w_check !word _0_ '='? _0_ init:expr_multi? sep:comma_sep? {
      return [id, init, sep, location()];
    }
  )* _0_ eos {
    if (!items || items.length === 0) {
      addDiagnostic(location(), `Expected following identifier and initial value.`, ERROR);
      return INVALID_STATEMENT;
    }

    const item = items[0];

    if (items.length > 1) {
      addDiagnostic(location(), `Only single constant can be decleared per statement.`, ERROR);
    } else if (item[2]) {
      addDiagnostic(location(), `Trailing comma not allowed.`, ERROR);
    } else if (!item[1]) {
      addDiagnostic(item[3], `Expected initial value.`, ERROR);
      item[1] === NULL_LITERAL;
    }

    return {
      type: 'VariableDeclaration',
      declarations: [
        {
          type: 'VariableDeclarator',
          id: item[0],
          init: item[1],
        },
      ],
      kind: 'const',
    };
  }

/*
 * OTHER STATEMENTS
 */

/**
 * <BNF> delete assoc-elem-list [;]
 * <BNF> delete assoc-array [;]
 *
 * The BNF in the Grammer Rules does not seems described correctly.
 * Deleting associative array without specifying indexes, as shown below, yields a syntax error.
 * > global arr
 * > arr = [1: "foo"];
 * > delete arr
 */
delete_stmt =
  'delete' _1_ items:(
    items:_assoc_elem_list_item* {
      diagnoseEmptyArray(items, location(), 'associative array', ERROR);
      return items;
    }
   ) _0_ eos {
    const nodes = diagnoseListItems(items, 'associative array', 0);
    return {
      type: 'UnaryExpression',
      operator: 'delete',
      argument: (nodes && nodes.length > 0)? makeSequenceExpression(nodes) : NULL_EXPRESSION,
      prefix: true,
    };
  }

_assoc_elem_list_item =
  node:assoc_array sep:list_sep? {
    return [node, sep, location(), undefined];
  }
  /
  sep:list_sep {
    return [undefined, sep, location(), undefined];
  }

/**
 * <BNF> lscmd pattern-list-opt [;]
 * <BNF> syms pattern-list-opt [;]
 * <BNF> lsdef pattern-list-opt [;]
 * <BNF> prdef pattern-list-opt [;]
 */
pattern_stmt =
  name:('lscmd' / 'lsdef' / 'prdef' / 'syms') !word _0_ items:_pattern_list_item* _0_ eos {
    let nodes = [];
    if (items && items.length > 0) {
      nodes = diagnoseListItems(items, 'pattern', 2);
    }
    return {
      type: 'MacroStatement',
      callee: { type: 'Identifier', name: name, },
      arguments: nodes,
    };
  }

_pattern_list_item =
  node:pattern_w_check sep:list_sep? {
    return [node, sep, location()];
  }
  /
  sep:list_sep {
    return [undefined, sep, location()];
  }

pattern_w_check =
  $[a-zA-Z0-9_*?] {
    return {
      type: 'literal',
      value: text(),
      raw: text(),
    };
  }

/**
 * <BNF> memstat [;]
 * <BNF> savstate [;]
 * <BNF> reconfig [;]
 * <BNF> getcounts [;]
 * <BNF> move_all [;]
 * <BNF> move_cnt [;]
 * <BNF> sync [;]
 */
builtin_macro_stmt =
  name:('memstat' / 'savstate' / 'reconfig' / 'getcounts' / 'move_all' / 'move_cnt' / 'sync') _0_ eos {
    return {
      type: 'MacroStatement',
      callee: { type: 'Identifier', name: name, },
      arguments: [],
    }
  }

/**
 * <BNF> expression [;]
 */
expr_stmt 'expression statement' =
  items:expr_multi_list _0_ eos {
    return {
      type: 'ExpressionStatement',
      expression: makeSequenceExpression(items),
    };
  }

/*
 * EXPRESSION
 *
 * The priority of the operators are not documented in the Grammer Rules.
 * Instad, this PEG grammer follows that of C-language (https://en.wikipedia.org/wiki/Order_of_operations).
 * 
 * There are two operators not included in C-language, 'in' operator and empty operator for string concatenation.
 * It seems the priority of string concatenation is higher than that of assignment but
 * lower than that of ternary operators.
 */

/**
 * expression that does not include concatenation.
 *
 * function_call and update_expr must precede lvalue.
 * update_expr must precede unary_expr.
 */
expr_solo 'expression' =
  expr_term15

/**
 * The core expression rules with operators haiving the 1st and 2nd priorities.
 */
expr_term2 =
  string_literal / numeric_literal / array_literal / expr_block / function_call
  / update_expr / unary_expr
  / lvalue / invalid_expr

/**
 * <BNF> identifier
 *
 * The symbols $1, $2, ... within ordinary macros are replaced by 
 * the arguments with which the macro is invoked.
 * Therefore, it is difficult to gramatically define these symbols.
 * Expediently, this PEG grammer treats them as identifiers.
 */
identifier 'identifier' =
  strict_identifier
  /
  name:$('$' ('#' / '*' / [0-9]+)) {
    return {
      type: 'Identifier',
      name: name,
    };
  }
  /
  op:'@' _0_ arg:identifier? {
    if (!arg) {
      addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
    }
    return {
      type: 'UnaryExpression',
      operator: '@',
      argument: arg ? arg : NULL_LITERAL,
      prefix: true,
    };
  }

strict_identifier =
  name:$([a-zA-Z_][a-zA-Z0-9_]*) {
    if (reservedKeywords.has(name)) {
      addDiagnostic(location(), `${name} is a reserved keyword.`, ERROR);
    // } else if (name === 'const') {
    //   addDiagnostic(location(), `Using ${name} for \"constant\"?`, INFORMATION);
    // } else if (name === 'elseif' || name === 'elif') {
    //   addDiagnostic(location(), `Using ${name} for \"else if\"?`, INFORMATION);
    }
    return {
      type: 'Identifier',
      name: name,
    };
  }

// / [a-zA-Z0-9_.+\-*/%!?^~\\]+
identifier_w_check =
  identifier / invalid_expr
  // / [a-zA-Z0-9_.+\-*/%!?^~\\]+ {
  //   addDiagnostic(location(), 'invalid as an identifier', ERROR);
  //   return {
  //     type: 'Identifier',
  //     name: text(),
  //   };
  // }

/**
 * <BNF> identifier
 * <BNF> identifier[expression]
 * <BNF> identifier[expression][expression]
 *
 * e.g., _foo12, bar[myfunc(a)], bar[], bar[:], bar[:4], bar[2:],  bar[1, 2, 3:5], ...
 */
lvalue 'left value' =
  id:identifier arr_dims:(
    _0_ arr_dim:array_element { return arr_dim; }
  )* {
    return arr_dims.reduce((accumulator: any, currentValue: any) => {
      return {
        type: 'MemberExpression',
        object: accumulator,
        property: currentValue,
        computed: true,
      };
    }, id);
  }

array_element =
  _0_ '[' _0_ item_0:slicable_index? items_1_n:(
    sep:comma_sep item:slicable_index? { return item ? item : NULL_LITERAL; }
  )* _0_ closer:']'? {
    if (!closer) {
      addDiagnostic(shortenLocation(location(), 1), 'Unterminated bracket.', ERROR);
    }
    item_0 = item_0 ? item_0 : NULL_LITERAL;
    if (items_1_n && items_1_n.length > 0) {
      return {
        type: 'SequenceExpression',
        expressions: [item_0].concat(items_1_n),
      };
    } else {
      return item_0;
    }
  }

/**
 * respective item of the comma-separated index. It can be:
 * - expression
 * - expression? : expression?
 */
slicable_index =
  ll:expr_multi? _0_ ':' _0_ rr:expr_multi? {
    return {
      type: 'BinaryExpression',
      operator: ':',
      left: ll ? ll : NULL_LITERAL,
      right: rr ? rr : NULL_LITERAL,
    };
  }
  /
  expr_multi

assoc_array = lvalue

invalid_expr =
  '{' eos? _0_ stmts:expr_multi_list? _0_ '}'? eos? {
    addDiagnostic(location(), 'Braces are to bundle statements. Use parentheses "()" for expressions.', ERROR);
    return NULL_EXPRESSION;
  }
  /
  value:$[^#,'"(){}[\];: \t\r\n]+ {
    addDiagnostic(location(), 'Invalid expression. It should be quoted if it is a string.', WARNING);
    return {
      type: 'Literal',
      value: text(),
      raw: text(),
    };
  }
// +-*/%^&|=

/**
 * <BNF> string-constant
 *
 * e.g., "foo,\"bar\"\n123", \'foo\'
 */
string_literal 'string literal' =
  '"' chars:(
    '\\' q:(
      p:[abfnrt'"\\$] { return getEscapeSequence(p); }
      /
      p:$([0-7][0-7]?[0-7]?) { return String.fromCharCode(parseInt(p, 8)); }
      /
      p:. {
        const loc = location();
        loc.start.offset -= 1;
        loc.start.column -= 1;
        addDiagnostic(loc, 'Unknown escape sequence.', WARNING);
        return p;
      }
    ) { return q; }
    /
    [^"]
  )* closer:'"'? {
    if (!closer) {
      addDiagnostic(shortenLocation(location(), 1), 'Unterminated string literal.', ERROR);
    }
    return {
      type: 'Literal',
      value: chars.join(''),
      raw: text(),
    };
  }
  / "\\'" chars:(
    '\\' q:(
      p:[abfnrt"\\$] { return getEscapeSequence(p); }
      /
      p:$([0-7][0-7]?[0-7]?) { return String.fromCharCode(parseInt(p, 8)); }
      /
      p:[^'] {
        const loc = location();
        loc.start.offset -= 1;
        loc.start.column -= 1;
        addDiagnostic(loc, 'Unknown escape sequence.', WARNING);
        return p;
      }
    ) { return q; }
    /
    $(!"\\'" .)
  )* closer:"\\'"? {
    if (!closer) {
      addDiagnostic(shortenLocation(location(), 2), 'Unterminated string literal.', ERROR);
    }
    return {
      type: 'Literal',
      value: chars.join(''),
      raw: text(),
    };
  }

/** 
 * <BNF> numeric-constant
 *
 * e.g., 0.1, 1e-3, 19, 017, 0x1f
 */
numeric_literal 'numeric literal' =
  out:(float / hexadecimal / octal / decimal) {
    return {
      type: 'Literal',
      value: out[1],
      raw: out[0],
    };
  }

float =
  (([0-9]+ (exponent / '.' [0-9]* exponent?)) / '.' [0-9]+ exponent?) {
    return [text(), parseFloat(text())];
  }

hexadecimal =
  '0' [xX] body:$[0-9a-fA-F]+ {
    return [text(), parseInt(body, 16)];
  }

octal =
  '0' body:$[0-7]+ {
    return [text(), parseInt(body, 8)];
  }

decimal =
  [0-9]+ {
    return [text(), parseInt(text(), 10)];
  }

exponent =
  [eE] [+-]? [0-9]+

/**
 * Array literals used in assingnment operation.
 * its BNF is undocumented in the Grammer Rules.
 * e.g., [ var0, 1+2, "test"], ["foo": 0x12, "bar": var1]
 */
array_literal 'array literal' =
  '[' _0_ item_0:(
    item:array_item? {
      if (!item) {
        addDiagnostic(location(), 'Expected an array element.', ERROR);
        return NULL_LITERAL;
      }
      return item;
    }
  ) items_1_n:(
    sep:comma_sep item:array_item? {
      if (!item) {
        addDiagnostic(location(), 'Expected an array element.', ERROR);
        return NULL_LITERAL;
      }
      return item;
    }
  )* _0_ closer:']'? {
    if (!closer) {
      addDiagnostic(shortenLocation(location(), 1), 'Unterminated bracket.', ERROR);
    }
    const items = [item_0].concat(items_1_n);
    
    if (items.some((item: any) => item === NULL_LITERAL)) {
      return NULL_EXPRESSION;
    } else if (items.every((item: any) => item.type === 'Property')) {
      // every item is a key-value pair.
      return {
        type: 'ObjectExpression',
        properties: items,
      };
    } else if (items.every((item: any) => item.type !== 'Property')) {
      // every item is an expression (not a key-value pair).
      return {
        type: 'ArrayExpression',
        elements: items,
      };
    } else {
        addDiagnostic(location(), 'Mixture of associate-array and data-array literals not allowed.', ERROR);
        return NULL_EXPRESSION;
    }
  }

/**
 * An item in array-literal, either a colon-separated pair of expressions or a single expression.
 * <NOTICE> While 'key' property must be a 'Literal' or 'Identifier' in the Parser AST,
 * <NOTICE> that of spec can be an 'Expression'.
 */
array_item =
  key:expr_multi? _0_ ':' _0_ value:expr_multi? {
    if (!key) {
      addDiagnostic(location(), `Expected a key expression.`, ERROR);
    } else if (!value) {
      addDiagnostic(location(), `Expected a value expression.`, ERROR);
    }
    return {
      type: 'Property',
      key: key ? key : NULL_LITERAL,
      value: value ? value : NULL_LITERAL,
      kind: 'init',
    };
  }
  / expr_multi


/**
 * <BNF> ( expression )
 * Expression in the Parser AST must not be null.
 */
expr_block 'parentheses that enclose expression' =
  '(' _0_ expr:expr_multi? _0_ closer:')'? {
    if (!expr) {
      addDiagnostic(location(), `Expected an expression in the parentheses.`, ERROR);
      return NULL_EXPRESSION;
    } else if (!closer) {
      addDiagnostic(shortenLocation(location(), 1), 'Unterminated parenthesis.', ERROR);
    }
    return expr;
  }

/**
 * <BNF> function(expression-list)
 *
 * Respective arguments must be separated with a comma.
 * It seems spec does not allow string concatenation of arguments.
 */
function_call 'function call' =
  expr:strict_identifier _0_ args:(
    '(' _0_ args:expr_solo_list? _0_ closer:')'? {
      if (!closer) {
        addDiagnostic(shortenLocation(location(), 1), 'Unterminated parenthesis.', ERROR);
      }
      return args;
    }
  ) {
    return {
      type: 'CallExpression',
      callee: expr,
      arguments: args ? args : [],
    };
  }


/**
 * <BNF> + expression
 * <BNF> - expression
 * <BNF> ! expression
 * <BNF> ~ expression
 */
unary_expr 'unary expression' =
  op:('+' / '-' / '!' / '~') _0_ arg:expr_solo? {
    if (!arg) {
      addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
    }
    return {
      type: 'UnaryExpression',
      operator: op,
      argument: arg ? arg : NULL_LITERAL,
      prefix: true,
    };
  }

/**
 * <BNF> ++ lvalue
 * <BNF> −− lvalue
 * <BNF> lvalue ++
 * <BNF> lvalue −−
 */
update_expr 'update expression' =
  op:update_op _0_ arg:lvalue? {
    if (!arg) {
      addDiagnostic(location(), `Expected an lvalue following \"${op}\" operator.`, ERROR);
    }
    return {
      type: 'UpdateExpression',
      operator: op,
      argument: arg ? arg : NULL_LITERAL,
      prefix: true,
    };
  }
  / arg:lvalue _0_ op:update_op {
    return {
      type: 'UpdateExpression',
      operator: op,
      argument: arg,
      prefix: false,
    };
  }

update_op = '++' / '--'

/**
 * <BNF> expression binop expression
 * 3rd priority: * / %
 */
expr_term3 =
  head:expr_term2 tails:(
    _0_ op:$(('*' / '/' / '%') !'=') _0_ term:expr_term2? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 4th priority: + -
 */
expr_term4 =
  head:expr_term3 tails:(
    _0_ op:$(('+' / '-') !'=') _0_ term:expr_term3? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 5th priority: << >>
 */
expr_term5 =
  head:expr_term4 tails:(
    _0_ op:$(('<<' / '>>') !'=') _0_ term:expr_term4? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 6th priority: < <= > >=
 */
expr_term6 =
  head:expr_term5 tails:(
    _0_ op:($('<' !'<' '='?) / $('>' !'>' '='?)) _0_ term:expr_term5? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 7th priority: == !=
 */
expr_term7 =
  head:expr_term6 tails:(
    _0_ op:('==' / '!=') _0_ term:expr_term6? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 8th priority: &
 */
expr_term8 =
  head:expr_term7 tails:(
    _0_ op:$('&' ![&=]) _0_ term:expr_term7? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 9th prioirity: ^
 */
expr_term9 =
  head:expr_term8 tails:(
    _0_ op:$('^' !'=') _0_ term:expr_term8? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 10th prioirity: |
 */
expr_term10 =
  head:expr_term9 tails:(
    _0_ op:$('|' ![|=]) _0_ term:expr_term9? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * <BNF> expression binop expression
 * 11th prioirity: &&
 */
expr_term11 =
  head:expr_term10 tails:(
    _0_ op:'&&' _0_ term:expr_term10? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails, 1);
  }

/**
 * <BNF> expression binop expression
 * 12th prioirity: ||
 */
expr_term12 =
  head:expr_term11 tails:(
    _0_ op:'||' _0_ term:expr_term11? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails, 1);
  }

/*
 * <BNF> expression ? expression : expression
 * 13th priority: ? :
 */
expr_term13 =
  head: expr_term12 tails:(
    _0_ '?' _0_ cons:expr_term12? _0_ alt:(
      ':' _0_ alt:expr_term12? {
        return alt;
      }
    )? {
      if (!alt) {
        addDiagnostic(location(), 'Expected an altenative expression following \":\" opearator.', ERROR);
        alt = NULL_LITERAL;
      } else if (!cons) {
        addDiagnostic(location(), 'Expected a consequent expression following \"?\" opearator.', ERROR);
        cons = NULL_LITERAL;
      }
      return [cons, alt];
    }
  )* {
    return tails.reduce((accumulator: any, currentValue: any) => {
      const cons = currentValue[0];
      const alt = currentValue[1];
      return {
        type: 'ConditionalExpression',
        test: accumulator,
        left: cons,
        right: alt,
      };
    }, head);
  }

/*
 * <BNF> lvalue asgnop expression
 * 14th priority: = += -= *= /= %= &= |= ^= <<= >>=
 */
expr_term14 =
  head:expr_term13 tail:(
    _0_ op:assignment_op _0_ term:expr_multi? {
      if (!term) {
        addDiagnostic(location(), `Expected an expression following \"${op}\" operator.`, ERROR);
        term = NULL_LITERAL;
      }
      return [op, term];
    }
  )? {
    if (!tail) {
      return head;
    } else {
      if (head.type !== 'Identifier' && head.type !== 'MemberExpression') {
        addDiagnostic(location(), 'Left-side value must be assignable.', ERROR);
      }
      const op = tail[0];
      const term = tail[1];
      return {
        type: 'AssignmentExpression',
        operator: op,
        left: head,
        right: term,
      };
    }
  }

assignment_op =
  $('=' !'=') / '+=' / '-=' / '*=' / '/=' / '%='
  / '<<=' / '>>=' / '&=' / '^=' / '|='

/*
 * <15th priority> in
 * <BNF> expression in assoc-array
 * 
 * Though not documented, it seems 'in' operator has lower priority than assignment operators.
 *  > myvar = "key" in assoc_array; print myvar
 * returns "key".
 */
expr_term15 =
  head:expr_term14 tails:(
    _0_ op:'in' !word _0_ term:assoc_array? {
      if (!term) {
        addDiagnostic(location(), `Expected an associative array following \"${op}\" operator.`, ERROR);
      }
      return [op, term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/*
 * <The last priority> concatenation
 * <BNF> expression expression
 * 
 * expression that includes concatenation (e.g., "1" "2" yields "12")
 * Though not documented in the Grammer Rules, this rule can be
 * used in limited contexts of the expression.
 */
expr_multi =
  head:expr_solo tails:(
    spaces:_0_ term:expr_solo {
      if (!spaces || spaces.length === 0) {
        addDiagnostic(location(), 'Expressions should be separated with whitespace.', INFORMATION);
      }
      return [' ', term];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/**
 * This rule allow concatenation of the expression like expr_multi but 
 * throws an error.
 */
expr_solo_forced =
  head:expr_solo tails:(
    _0_ tail:expr_solo {
      addDiagnostic(location(), 'Expression concatenation not allowed.', ERROR);
      return [' ', tail];
    }
  )* {
    return getBinaryExpression(head, tails);
  }

/*
 * BNF> expression, expression
 * Though these are recursively defined as 'expression' in the Grammer Rules, 
 * the spec interpretter sometimes treats them differently.
 * For example, a = 1, b = 2 can not be used for the test expression in if-clause
 * (though it is written "if (expression) statement" in the Grammer Rules).
 */

/**
 * Comma-separated expression list in which concatenation of the expressions is not allowed.
 */
expr_solo_list 'comma-separated expression list' =
  item_0:expr_solo_forced items_1_n:_expr_solo_list_item* {
    return [item_0].concat(items_1_n);
  }
  /
  items_1_n:_expr_solo_list_item+ {
    addDiagnostic(shortenLocation(location(), 0), 'Expected an expression.', ERROR);
    return [NULL_LITERAL].concat(items_1_n);
  }

_expr_solo_list_item =
  comma_sep item:expr_solo_forced? {
    if (!item) {
      addDiagnostic(location(), 'Expected an expression.', ERROR);
      return NULL_LITERAL;
    }
    return item;
  }

/**
 * Comma-separated expression list in which concatenation of the expressions is also allowed.
 */
expr_multi_list 'comma-separated expression list' =
  item_0:expr_multi items_1_n:_expr_multi_list_item* {
    return [item_0].concat(items_1_n);
  }
  /
  items_1_n:_expr_multi_list_item+ {
    addDiagnostic(shortenLocation(location(), 0), 'Expected an expression.', ERROR);
    return [NULL_LITERAL].concat(items_1_n);
  }

_expr_multi_list_item =
  comma_sep item:expr_multi? {
    if (!item) {
      addDiagnostic(location(), 'Expected an expression.', ERROR);
      return NULL_LITERAL;
    }
    return item;
  }
