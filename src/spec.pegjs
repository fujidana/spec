/** 
 * This is a **spec** grammer file written in PEG.js (https://pegjs.org) format.
 * The parser generated by PEG.js parses a spec script and outputs a 
 * javascript object similar to the following AWT (abstract syntax tree):
 * https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API.
 */

start = p:statement* {
    return {
        type: "Program",
        body: p,
    };
}

// # miscellaneous

eol         = '\n' / '\r\n'
eof         = !.
eos_not_eof = eol / comment / ';'
eos         = eol / comment / ';' / eof / & ['}]
comment     = '#' p:$(!eol .)* (eol / eof) { return p; }

space       = $(' ' / '\t' / '\\' eol / docstring)
spaces      = $(' ' / '\t' / '\\' eol / docstring)+
opt_spaces  = $(' ' / '\t' / '\\' eol / docstring)*
docstring   = '"""' p:$(!'"""' .)* '"""' { return p; }

eos_space  = $(' ' / '\t' / '\\' eol / docstring / eol / comment)


string = '"' $[^"]* '"' / "\\'" $(!("\\'" / "'") .)* "\\'"
macro_argument = $('$' ([0-9][0-9]? / '*' / '#'))
expression_block = '(' opt_expression ')'
word  = $[a-zA-Z0-9_]+

// # expressions (to be refined in future)

expression = p:$(expression_block / macro_argument / spaces / string / [^'"#$;\r\n(){}])+ {
    return {
        type: "Expression",
        value: p,
    };
}

opt_expression = p:$(expression_block / macro_argument / spaces / string / [^'"#$;\r\n(){}])* {
    return {
        type: "Expression",
        value: p,
    };
}

// # statements

statement = p:(
    docstring_statement / comment_statement / empty_statement / 
    block_statement / 
    if_statement / break_statement / continue_statement / return_statement / 
    while_statement / for_statement / for_in_statement / 
    function_declaration / variable_declaration / 
    another_statement
) {
    return  p;
}

// ## empty statements

comment_statement = $(' ' / '\t')* p:comment {
    return {
        type: 'EmptyStatement',
        // location: location(),
        comment: p,
    };
}

docstring_statement = $(' ' / '\t')* p:docstring opt_spaces eos {
    return {
        type: 'EmptyStatement',
        // location: location(),
        docstring: p,
    };
}

empty_statement = $(opt_spaces eos_not_eof / spaces eos) {
    return {
        type: 'EmptyStatement',
        // location: location(),
    };
}

// ## block statement

block_statement = opt_spaces '{' eos? p:statement* opt_spaces '}' eos? {
    return {
        type: 'BlockStatement',
        // location: location(),
        body: p,
    };
}

// ## flow statements (condition and loop)

if_statement = opt_spaces 'if' opt_spaces '(' p:expression ')' q:statement r:else_statement? {
    return {
        type: 'IfStatement',
        // location: location(),
        test: p,
        consequence: q,
        alternate: r,
    };
}

// auxiliary item for if_statement
else_statement = eos_space* 'else' !word p:statement {
    return p;
}

break_statement = opt_spaces 'break' opt_spaces eos {
    return {
        type: 'BreakStatement',
        // location: location(),
        label: null,
    };
}

continue_statement = opt_spaces 'continue' opt_spaces eos {
    return {
        type: 'ContinueStatement',
        // location: location(),
        label: null,
    };
}

return_statement = opt_spaces 'return' !word opt_spaces p:expression? opt_spaces eos {
    return {
        type: 'ReturnStatement',
        // location: location(),
        argument: p,
    };
}

while_statement = opt_spaces 'while' opt_spaces '(' p:expression ')' q:statement {
    return {
        type: 'WhileStatement',
        // location: location(),
        test: p,
        body: q,
    };
}

// for_statement = opt_spaces 'for' opt_spaces '(' opt_spaces (word 'in' expression / opt_expression ';' opt_expression ';' opt_expression) opt_spaces ')' {
for_statement = opt_spaces 'for' opt_spaces '(' opt_spaces p:opt_expression opt_spaces ';' opt_spaces q:opt_expression opt_spaces ';' opt_spaces r:opt_expression opt_spaces ')' s:statement {
    return {
        type: 'ForStatement',
        // location: location(),
        init: p,
        test: q,
        update: r,
        body: s,
    };
}

for_in_statement = opt_spaces 'for' opt_spaces '(' opt_spaces p:word opt_spaces 'in' opt_spaces q:expression opt_spaces ')' r:statement {
    return {
        type: 'ForInStatement',
        // location: location(),
        left: p,
        right: q,
        body: r,
        each: false
    };
}

// ## declarations

// !!! argument is not validated.
function_declaration = opt_spaces 'def' spaces id_name:word params:function_arguments? opt_spaces "'" eos? body:statement* "'" opt_spaces eos {
    return {
        type: 'FunctionDeclaration',
        location: location(),
        id: { type: 'Identifier', name: id_name},
        params: params,
        // defaults: [ Expression ],
        // rest: Identifier | null,
        body: body,
        generator: false,
        expression: false,
    };
}

// auxiliary item for function_declaration
function_arguments = '(' p:$(word / ',' / space )* ')' {
    return p.trim().split(/\s+|\s*,\s/);
}

// !!! local id is not validated.
variable_declaration = opt_spaces kind:('local' / 'global' / 'unglobal') spaces ids_str:$(word (word / [\[\],] / space)*) opt_spaces eos {
    const ids_arr = ids_str.trim().split(/\s+|\s*,\s/);
    const declarators = [];
    for (const id_name of ids_arr) {
        declarators.push({
            type: "VariableDeclarator",
            id: { type: 'Identifier', name: id_name},
            init: null,
        });
    }
    return {
        type: 'VariableDeclaration',
        // location: location(),
        declarations: declarators,
        kind: kind,
    };
}

another_statement = opt_spaces p:$(expression / spaces)+ eos {
    return {
        type: 'Statement',
        // location: location(),
        statement: p
    };
}
